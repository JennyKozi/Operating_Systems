Λειτουργικά Συστήματα 2023 - Τμήμα Αρτίων - Προγραμματιστική Άσκηση 1

Ευγενία Κοζή
Α.Μ: 1115202000082

Με το Makefile το πρόγραμμα μεταγλωττίζεται με χρήση separate compilation και linker (δηλαδή ξεχωριστή μεταγλώττιση κάθε αρχείου κώδικα .c και δημιουργία .o αρχείων).

Έχει γίνει έλεγχος με valgrind και το πρόγραμμα δεν έχει memory leaks.

Γίνεται πάντα έλεγχος αν δεσμεύτηκε η μνήμη από τη malloc και αν αποτύχει το πρόγραμμα τερματίζει.

Όλες οι δομές δημιουργούνται και επεκτείνονται δυναμικά όσο τρέχει το πρόγραμμα.

Δε γίνεται χρήση στατικών πινάκων/δομών που δεσμεύονται στη διάρκεια της συμβολομετάφρασης του προγράμματος.

Ενδεικτικές εντολές run:
./mvote -f voters50.csv -b 3
./mvote -b 6 -f voters500.csv
./mvote -f voters5000.csv -b 5
./mvote -f voters50000.csv -b 4
./mvote -f voters100000.csv -b 5

MAIN:

Γίνονται έλεγχοι ότι έχουμε δώσει σωστά arguments και flags στην εντολή εκτέλεσης του προγράμματος.

Δεν πρέπει να υπάρχουν διπλότυπα, οπότε αν στο αρχείο registeredvoters που δίνουμε στη γραμμή εντολών βρεθεί διπλότυπο, τυπώνεται μήνυμα λάθους και τερματίζει το πρόγραμμα. (οδηγία από το piazza)
Δε γίνονται άλλοι έλεγχοι για τη μορφή των δεδομένων του αρχείου registeredvoters (δεν αναφέρεται πουθενά στην εκφώνηση), διότι θεωρούμε ότι ΕΙΝΑΙ ΣΩΣΤΟ και ΣΩΣΤΑ ΔΟΜΗΜΕΝΟ (όπως τα αρχεία που μας δόθηκαν voters50.csv κλπ).

Για τα μεγάλα αρχεία με 50000 και 100000 voters μπορεί να αργήσουν λίγο να φορτωθούν όλα τα δεδομένα.
Το πρόγραμμα είναι έτοιμο να δεχτεί τις εντολές για την mvote μόλις βγει το μήνυμα "Insert command: ".

Η global μεταβλητή num_bytes μετράει συνολικά για όλο το πρόγραμμα τα bytes που δεσμεύονται και αποδεσμεύονται δυναμικά κατά τη διάρεκεια εκτέλεσης και η τιμή της στο τέλος όταν δώσουμε την
εντολή exit είναι τα bytes που απελευθερώνει το πρόγραμμα στην έξοδό του.

Γίνονται κατάλληλοι έλεγχοι για την είσοδο που δίνουμε στις εντολές που το ζητάει το output format που μας δόθηκε (εντολές 1-4).
Πρέπει τα pin, zip να είναι ακέραιοι και να μην περιέχουν γράμματα και τα first name, last name να μην περιέχουν αριθμούς.

Για την εντολή m αν ο voter δεν έχει ψηφίσει, τον εισάγουμε στη λίστα, αλλάζουμε το status του και εκτυπώνουμε το μήνυμα.
Ενώ αν έχει ψηφίσει απλώς εκτυπώνουμε το μήνυμα.

Για την εντολή bv γίνεται επαναληπτικά για κάθε pin του αρχείου που δίνουμε ό,τι γίνεται με την εντολή m.

VOTER: μια δομή που ορίζεται στο voter.h και περιέχει όλες τις πληροφορίες για κάθε voter.

HASH TABLE:

Στο hash_table.h έχει οριστεί η δομή του Bucket, του hash_table και υπάρχουν τα function prototypes που χρησιμοποιεί η main.
Στο hash_table.c βρίσκεται ο κώδικας για τις συναρτήσεις του hash table.

Κάθε bucket περιέχει:
*Ένα array (με αριθμό θέσεων που ορίζεται από το bucketentries) από δείκτες σε voters.
Οι voters αυτοί δημιουργήθηκαν στη main δυναμικά (βρίσκονται αποθηκευμένοι στον σωρό) και με έναν δείκτη σε καθέναν τους μπορούμε να έχουμε πρόσβαση.
*Έναν δείκτη σε overflow bucket.
*Το count που δείχνει πόσους δείκτες σε voters περιέχουν τώρα (count <= bucketentries).

Ένα hash_table περιέχει:
*Έναν πίνακα δεικτών σε buckets (αρχικά έχει m τέτοιους δείκτες)
*m: χρησιμοποιείται για το modulo της hash function
*p: τιμή του είναι το index του bucket που θα γίνει split όταν ξεπεράσουμε το threshold
*num_keys: είναι ο συνολικός αριθμός εγγραφών που περιέχει το hash table
*num_buckets: είναι ο αριθμός των non-overflow buckets που έχει το hash table
*bucketentries: δίνεται από τον χρήστη και είναι ο μέγιστος αριθμός εγγραφών που μπορεί να έχει ένα bucket

Αν έχει γεμίσει ένα bucket και πρέπει να εισαχθεί εγγραφή σε αυτό, τότε δημιουργείται ένα overflow bucket.
Θεωρητικά κάθε bucket μπορεί να έχει όσα overflow buckets χρειαστούν μέχρι να γίνει split.

Έχει οριστεί ότι ο αρχικός αριθμός buckets που θα έχει το hash table είναι m=4.

Το threshold έχει οριστεί να είναι 0.75. Η η μεταβλητή l υπολογίζεται μετά από κάθε εισαγωγή εγγραφής.
Αν ξεπεράσουμε το 0.75, το bucket που δείχνει ο δείκτης p γίνεται split σε δύο buckets.
Το νέο bucket εισάγεται στο τέλος των buckets.

Σε κάθε round η hash function για το linear hashing χρησιμοποιεί το mod m και το mod 2*m (κατανομή των εγγραφών σε buckets).

Μόλις ολοκληρωθεί ένα round (δηλαδή έχουμε τον διπλάσιο αριθμό buckets από όσους είχαμε όταν ξεκινήσαμε αυτό το round), το m διπλασιάζεται και ο δείκτης p δείχνει το πρώτο bucket.

Πολυπλοκότητα:
Έστω n οι εγγραφές στο hash table και k τα buckets του.

*Create_HT: O(1)
*Insert_HT: O(1), δύο πιθανοί κουβάδες στους οποίους μπορεί να μπει μια νέα εγγραφή (hash function)
*Search_HT: O(1), δύο πιθανοί κουβάδες στους οποίους μπορεί να βρίσκεται μια εγγραφή (hash function)
*Delete_HT: O(n+k), διαγράφουμε k κουβάδες και n εγγραφές συνολικά (θεωρούμε ότι τα overflow buckets δεν επηρεάζουν τη συνολική πολυπλοκότητα)

2D LIST:

Στο 2d_list.h έχει οριστεί η δομή της διδιάστατης λίστας (ListNode_2d), της μονοδιάστατης λίστας (ListNode) και υπάρχουν τα function prototypes που χρησιμοποιεί η main.
Στο 2d_list.c βρίσκεται ο κώδικας για τις συναρτήσεις της διδιάστατης λίστας.

Κάθε κόμβος διδιάστατης λίστας περιλαμβάνει:
*zipcode: Ο Τ.Κ. των voters που έχουν εισαχθεί σε αυτόν τον κόμβο επειδή έχουν ψηφίσει
*count: Ο αριθμός των voters με αυτό το zip που έχουν ψηφίσει
*Δείκτη σε επόμενο κόμβο 2d λίστας
*Δείκτη σε λίστα μονοδιάστατη με δείκτες στους voters με το συγκεκριμένο zipcode που έχουν ψηφίσει

Οι κόμβοι της 2d λίστας είναι πάντα ταξινομημένοι σε φθίνουσα σειρά ως προς τον αριθμό των voters που έχουν ψηφίσει από κάθε zipcode.
Αυτό γίνεται με αναδιάταξη των κόμβων από την Insert_List, η οποία κάνει κατάλληλο έλεγχο μετά από κάθε εισαγωγή.
Η ταξινομημένη εισαγωγή είναι απαραίτητη για την εκτέλεση της εντολής o.

Η συνάρτηση Print_Zip_List εκτελεί την εντολή z.
Η συνάρτηση Print_Descending_List εκτελεί την εντολή o.

Πολυπλοκότητα:
Έστω n οι εγγραφές της 2d list και k οι κόμβοι της (2d_node). 

*Create_List: O(1)
*Insert_List: O(k), διατρέχουμε όλους τους κόμβους της 2d list μέχρι να βρούμε τον κόμβο με το zipcode του voter που θέλουμε να εισάγουμε τώρα
Αν δεν τον βρούμε, δημιουργούμε στο τέλος έναν καινούργιο κόμβο και κάνουμε εκεί εισαγωγή.
*Size_List: O(k), διατρέχουμε όλους τους κόμβους της λίστας
*Delete_List: (n+k), διατρέχουμε όλους τους κόμβους της 2d list και όλους τους κόμβους της κάθεμιας μονοδιάστατης λίστας με voters
