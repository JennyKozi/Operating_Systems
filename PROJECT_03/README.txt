Λειτουργικά Συστήματα 2023 - Τμήμα Αρτίων - Προγραμματιστική Άσκηση 3

Ευγενία Κοζή
Α.Μ: 1115202000082

Με το Makefile το πρόγραμμα μεταγλωττίζεται με χρήση separate compilation και linker (δηλαδή ξεχωριστή μεταγλώττιση κάθε αρχείου κώδικα .c και δημιουργία .o αρχείων).

Έχει γίνει έλεγχος με valgrind και το πρόγραμμα δεν έχει memory leaks.

Γίνεται πάντα έλεγχος αν δεσμεύτηκε η μνήμη από τη malloc και αν αποτύχει το πρόγραμμα τερματίζει.

Γίνεται πάντα έλεγχος για το αν άνοιξε σωστά το αρχείο με την open/fopen.
Πάντα κλείνουμε το αρχείο με close/fclose.

Γίνονται εκτυπώσεις κατά την εκτέλεση των προγραμμάτων που δείχνουν την πορεία τους και τι κάνουν σε κάποια σημαντικά σημεία.

Εκτέλεση εργασίας:
./myprog exec1.txt
./myprog exec2.txt

*header.h:
Αρχείο επικεφαλίδας με ορισμούς που χρειάζονται όλα τα .c αρχεία κώδικα.
Έχει τη δομή του shared memory segment και του record.

*myprog.c:
Το κύριο πρόγραμμα που εκτελούμε μία φορα, δημιουργεί το shared memory segment και με fork κι exec δημουργεί και ξεκινάει την εκτέλεση των readers και writers,
χρησιμοποιώντας εντολές εκτέλεσης όπως περιγράφεται στην εκφώνηση.
Περιμένει όλα τα processes να τελειώσουν και μετά εκτυπώνει τα στατιστικά, αποδεσμεύει τη μνήμη, καταστρέφει τους σημαφόρους και το shared memory segment.

*reader.c: Το πρόγραμμα του reader
*writer.c: Το πρόγραμμα του writer


Η ΙΔΕΑ ΓΙΑ ΤΗΝ ΕΚΤΕΛΕΣΗ:

Έχουμε ένα αρχείο που μέσα έχουμε γράψει εντολές εκτέλεσης (όπως περιγράφονται στην εκφώνηση) για προγράμματα reader, writer.
Οπότε εκεί γράφουμε τις παραμέτρους που θέλουμε για την εκτέλεση του κάθε προγράμματος, εκτός από το flag -s διότι δεν είναι ακόμα γνωστό.
Υπάρχουν δύο τέτοια αρχεία (exec1.txt, exec2.txt) για να δοκιμάσουμε το πρόγραμμα.
Αρκεί να τρέξουμε το εκταλέσιμο myprog και να του δώσουμε στη γραμμή εντολών ως όρισμα το αρχείο exec1.txt, exec2.txt ή ένα άλλο τέτοιο αρχείο με εντολές εκτέλεσης για readers, writers.
Το πρόγραμμα myprog δημιουργεί ένα shared memory segment και πλέον έχει το id του.
Διαβάζει τις εντολές εκτέλεσης από το αρχείο που δώσαμε και στο τέλος προσθέτει το flag -s shmid για να έχουμε την ολοκληρωμένη εντολή εκτέλεσης για reader ή writer.
Κάνοντας fork δημιουργεί μια νέα διεργασία και μετά ξεκινάει με exec η εκτέλεση μιας διεργασίας reader ή writer.
Αυτό επαναλαμβάνεται για όλες τις εντολές εκτέλεσης που υπάρχουν μέσα στο αρχείο που δίνουμε ως όρισμα, οπότε συνολικά τόσα processes (readers ή writers) δημιουργούνται.
Το myprog περιμένει να τελειώσουν όλα τα παιδιά του και μετά εκτυπώνει τα στατιστικά, αποδεσμεύει τη μνήμη, καταστρέφει τους σημαφόρους και το shared memory segment.


SHARED MEMORY SEGMENT:

Δομή σταθερού μεγέθους:
*pid_t readers_pid[ARRAY_SIZE]: Πίνακας με pids των readers
*pid_t writers_pid[ARRAY_SIZE]: Πίνακας με pids των writers
*int total_readers: συνολικός αριθμός readers που εκτελέστηκαν
*int total_writers: συνολικός αριθμός writers που εκτελέστηκαν
*int total_recs_processed: συνολικά πόσες εγγραφές διαβάστηκαν ή άλλαξαν
*int readers_recs[ARRAY_SIZE][2]:
	-Αν ο reader θέλει μόνο μία εγγραφή: πίνακας που έχει στη θέση 0 για κάθε reader το id της εγγραφής που θέλει και στη θέση 1 την τιμή 0 (δηλώνοντας ότι θέλει μόνο μία εγγραφή)
	-Αν ο reader θέλει πολλές εγγραφές: πίνακας που στη θέση 0 έχει το μικρότερο id από τα records που θέλει και στη θέση 1 έχει το μεγαλύτερο id
*int writers_recs[ARRAY_SIZEE]: πίνακας που έχει για κάθε writer το id της εγγραφής που θέλει
*double time_readers[ARRAY_SIZE]: πίνακας με τους runtime χρόνους που έκανε ο κάθε reader
*double time_writers[ARRAY_SIZE]: πίνακας με τους runtime χρόνους που έκανε ο κάθε writer
*sem_t mutex: σημαφόρος που προστατεύει βασικά δεδομένα που όλοι οι readers/writers αλλάζουν και όταν είναι να τα χρησιμοποιήσουν χρειάζονται τη σωστή τιμή τους
	και να μην αλλάξουν από κανέναν reader/writer εκείνη τη στιγμή: total_readers, total_writers, readers_recs, writers_recs
*sem_t sem_sum: Σημαφόρος που χρησιμοποιούν οι readers/writers για να αυξήσουν τις εγγραφές που διάβασαν/έγραψαν
*sem_t sem_new_reader: Σημαφόρος που χρησιμοποιούν οι readers για να βάλουν το pid τους στον πίνακα readers_pid και μετά να το βγάλουν
*sem_t sem_new_writer: Σημαφόρος που χρησιμοποιούν οι writers για να βάλουν το pid τους στον πίνακα writers_pid και μετά να το βγάλουν
*sem_t sem_readers_recs[ARRAY_SIZE]: Σημαφόρος για κάθε έναν από τους readers που όταν είναι κατεβασμένος δείχνει ότι είναι δεσμευμένο το record αυτού του reader
*sem_t sem_writers_recs[ARRAY_SIZE]: Σημαφόρος για κάθε έναν από τους readers που όταν είναι κατεβασμένος δείχνει ότι είναι δεσμευμένο το record αυτού του writer


ΛΥΣΗ ΠΡΟΒΛΗΜΑΤΟΣ READERS - WRITERS:

*Βασική ιδέα:
Το ARRAY_SIZE ορίζεται με define και είναι ο μέγιστος αριθμός readers και ο μέγιστος αριθμός writers που μπορούν να εκτελεστούν συνολικά.
Μόλις ξεκινήσει ένας reader/writer αποκτά έναν αριθμό 0 <= proc_index <= (ARRAY_SIZE - 1) που είναι μοναδικός (ανάμεσα στους readers ή ανάμεσα στους writers)
Δηλαδή σε αυτή τη θέση στους πίνακες ο reader/writer θα καταχωρεί το pid του, το id του record που θέλει, τον χρόνο που έκανε.
Μόλις τελειώσει η διεργασία, διαγράφει από τους πίνακες τα στοιχεία της, όμως σε αυτές τις θέσεις πίνακα δεν μπορούν να γράψουν άλλες διεργασίες.

Το myprog αρχικοποιεί όλους τους σημαφόρους στο 1.

*Αλγόριθμος:
Ο κάθε reader/writer κάνει attach το shared memory segment για να έχει πρόσβαση στις πληροφορίες.
Αρχικά ο reader/writer αυξάνει τον συνολικό αριθμό readers/writers που υπάρχουν, αποκτά το μοναδικό του proc_index και βάζει στον πίνακα
readers_recs/writers_recs το id του record που θέλει, στη θέση proc_index.
Κατεβάζει τον σημαφόρο sem_readers_recs[proc_index]/sem_writers_recs[proc_index] για να "δεσμεύσει" αυτήν την εγγραφή.
Βάζει το pid του στον πίνακα readers_pid/writers_pid στη θέση proc_index.
Οι readers/writers όταν ξεκινούν κρατάνε σε μια μεταβλητή το ποιος ήταν ο τελευταίος reader και writer που ήρθε πριν από αυτούς.

-Οι readers ψάχνουν να βρουν αν υπάρχει writer που ήρθε ΠΡΙΝ από αυτούς που να γράφει σε record/records που θέλουν (ο writer έχει δεσμεύσει το record με αυτό το id).
	Αν υπάρχει τότε σίγουρα ο σημαφόρος αυτού του writer είναι κατεβασμένος, άρα ο reader τον ξανακατεβάζει και μπλοκάρει μέχρι να τελειώσει ο writer και να ανεβάσει τον σημαφόρο του.
	Ο reader ξεμπλοκάρει, σηκώνει κι αυτός τον σημαφόρο του writer για να ξεμπλοκάρουν και οι άλλοι readers/writers που περίμεναν αυτόν τον writer και συνεχίζει το ψάξιμο.
-Οι writers ακολουθούν την παραπάνω διαδικασία απλώς πρώτα ψάχνουν να δουν αν κάποιος writer που ήρθε πριν από αυτούς γράφει στην εγγραφή που θέλουν και μετά ελέγχουν τους readers.

Οι readers/writers κάνουν sleep για τυχαίο χρόνο (max ο χρόνος που δώσαμε στην εντολή εκτέλεσης) και μετά κάνουν read/write.
Μετά βγάζουν το id/τα ids του record/των records που διάβασαν/έγραψαν από τον πίνακα readers_recs/writers_recs.
Ενημερώνουν τον συνολικό αριθμό εγγραφών και αφαιρούν το pid τους από τον πίνακα readers_pid/writers_pid.
Τέλος, γράφουν στη θέση proc_index του πίνακα time_readers/time_writers το runtime τους και τερματίζουν.

